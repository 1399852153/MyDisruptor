# MyDisruptor V4版本介绍
在v3版本的MyDisruptor实现多线程消费者后。按照计划，v4版本的MyDisruptor需要支持线程安全的多线程生产者功能。
#####
由于该文属于系列博客的一部分，需要先对之前的博客内容有所了解才能更好地理解本篇博客
* v1版本博客：[从零开始实现lmax-Disruptor队列（一）RingBuffer与单生产者、单消费者工作原理解析](https://www.cnblogs.com/xiaoxiongcanguan/p/16318972.html)
* v2版本博客：[从零开始实现lmax-Disruptor队列（二）多消费者、消费者组间消费依赖原理解析](https://www.cnblogs.com/xiaoxiongcanguan/p/16361197.html)
* v3版本博客：[从零开始实现lmax-Disruptor队列（三）多线程消费者WorkerPool原理解析](https://www.cnblogs.com/xiaoxiongcanguan/p/16386982.html)
# MyDisruptor支持多线程生产者
* 之前的v3版本实现了多线程消费者，提供并发消费的能力以加速消费速度。同理，disruptor也提供了多线程生产者机制以支持更快的生产速度。
* disruptor的多线程生产者机制，其本质是提供了一个线程安全的生产者序列器。
  线程安全的生产者序列器允许多个线程并发的通过next方法申请可用的生产序列号和publish发布序列号，内部通过cas机制保证每个生产者线程拿到的序列号是独一无二的。


* disruptor的多线程生产者中通过AvailableBuffer数组机制，巧妙的避免了多个线程发布时争抢生产者
### 如何设计一个线程安全的多生产者？
在开始介绍disruptor的实现方式之前，站在设计者的角度先思考一下如何设计一个线程安全的生产者序列器（功能和单线程生产者序列器几乎一致）。  

**首先第一个要解决的问题便是：如何保证多个线程能够给线程安全的获取序列号，不会获取到重复的序列号而互相覆盖？**   
可以参考多线程消费者，在next方法中通过cas的争抢来实现。  

disruptor的生产者生产时是分为两个阶段的，首先通过next方法获取可用的序列号，然后通过publish发布序列号，令生产完成的序列号对消费者可见，消费者监听到生产者序列号的变化便会进行对应的消费。
**第二个问题是二阶段生产+多线程并发的场景下，如何避免消费者消费到还未发布完成的事件？**    
举个例子，当前生产者已成功发布了序列号11，线程a通过next方法获取到了序列号12，线程b获取到了13，线程c获取到了14。此时线程c生产完毕后，如果按照常规的思路直接更新当前生产者序列为14的话是不行的。
因为这样消费者会认为14以及之前的12、13都已经发布完成，会错误的消费还未完成生产的序列号为12、13的事件。

**那么是否需要引入一个已发布的最小生产者序列号属性呢？**  
上述情况下，如果引入最小生产者序列号机制，那么虽然线程c生产完了序列14的事件，但对外可见的最小生产者序列号依然是11，不会有问题。  
**那么线程c完成了序列14的生产后，是否可以继续next获取新的序列15进行生产呢？**  
如果不可以，那么多线程生产者的吞吐量就会受到影响，性能大大降低。  
如果可以，当线程a、b完成了序列12、13的序列号生产后，又该如何知道序列14已经生产完成可以发布，使得最小生产者序列号能正确的变为14呢？

可以看到从设计者的角度出发，可以想到非常多的方案。其中有的可行，有的不可行；可行的方案中有的性能更好，有的更简洁优雅，读者可以尝试着发散一下思维，这里限于篇幅就不再展开了。
### 多线程生产者MyMultiProducerSequencer介绍
disruptor的设计者肯定也对各种方案进行了评估，下面我们就来看看disruptor开发团队认为的最好的多线程生产者设计方案吧。



