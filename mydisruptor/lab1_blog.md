# 1.lmax-Disruptor队列介绍
disruptor是英国著名的金融交易所lmax旗下技术团队开发的一款java实现的高性能内存队列框架。  
其发明disruptor的主要目的是为了改进传统的内存队列实现如jdk的ArrayBlockingQueue、LinkedBlockingQueue等在现代CPU硬件上的一些缺陷: 
##### 1. 伪共享问题 
   现代的CPU都是多核的，每个核心都拥有自己独立的高速缓存。高速缓存通常由固定大小的缓存行组成（通常为32个字节或64个字节）。  
   CPU是以缓存行作为最小单位读写的，而一个缓存行通常会被多个变量占据（32位的引用指针占4字节，64位的引用占8个字节）。  
   这样会导致一个问题，即使缓存行上的变量不相关联（比如不属于同一个对象），但只要缓存行上的一个共享变量发生了变化，则整个缓存行都会进行缓存一致性的同步。
   而CPU间缓存一致性的同步是有一定性能损耗的，能避免则尽量避免。这就是所谓的“**伪共享**”问题。  
   而disruptor通过对队列中一些关键变量进行了缓存行的填充，避免其因为不相干的变量读写而无谓的刷新缓存，解决了伪共享的问题。  
   关于CPU间缓存一致性相关的内容可以参考下我以前的博客：
   [高速缓存一致性协议MESI与内存屏障](https://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html)
##### 2. 过多的队头、队尾引用等共享变量的争抢
   传统的内存队列由于生产者、消费者都会并发的读写队列头、队列尾的引用和队列size， 
   因此被迫使用了如ReentrantLock等基于OS上下文切换的悲观锁或是CAS机制的乐观锁等互斥机制来保证队列关键数据在多线程并发场景下的安全，
   而即使是CAS这样非阻塞的机制，由于存在失败重试机制，其性能损耗在追求极限性能的高并发队列中间件上也是不容忽视的
   而disruptor在实现过程中巧妙的通过全局有序增长的序列号机制代替了显式的队列头、队列尾更新，大大减少了生产者和消费者间需要并发访问共享变量的场合，从而极大地提高了高并发场景下队列的吞吐量
   
##### 3. 入队、出队时队列元素产生大量垃圾
   juc包下的阻塞队列队列元素在入队时会被创建、出队被消费后就不再被引用从而产生大量的垃圾。 
   disruptor通过基于数组的环形队列，在开始运行前就用空的事件对象填充好整个队列，后续的生产与消费则不允许新增或者删除队列元素，
   而只能配合序列号机制，修改队列元素中的属性来进行生产者和消费者的交互。通过固定队列中的对象，而避免入队、出队时产生不必要的垃圾。  
##### 
   除此之外，disruptor还允许设置消费者间消费的依赖关系（例如A、B消费者消费完毕后，C才能消费），构造高效的事件传输管道，轻松实现1对1，1对多，多对1等模式的组合。   
   更详细的内容可以参考disruptor的官方文档：https://lmax-exchange.github.io/disruptor/disruptor.html  
   上面虽然介绍了有关disruptor的各种特点，但只有详细的研究源码后才能更好地理解disruptor的原理，体会其整体设计思路以及代码层面微观实现的精妙之处。
# 2.MyDisruptor介绍
编程和画画很类似，比起对着已经完工的画作进行分析，我更喜欢参考着原画从设计者的角度出发自己临摹出一副属于自己的画。在这个过程中，可以看到程序从简单到复杂的全过程，
能更清楚得知道哪些是核心功能而哪些是相对边缘的逻辑，从而获得一条相对平滑的学习路线。  
MyDisruptor就是我按照上述学习方式自己临摹出来的结果，按照功能模块大致分为六个迭代版本逐一完成，最终实现一个和disruptor相差无几的队列。在这个过程中，
由于低版本的代码会精简很多，可以让读者更容易理解当前功能的实现原理，而不会被其余旁路代码的复杂度给绕晕。
1. ringBuffer + 单线程生产者 + 单线程消费者
2. 多线程消费者 + 消费者组依赖关系（A/B -> C, AB消费成功后C才能消费）
3. worker线程组消费者
4. 多线程生产者
5. disruptor dsl(提供简单易用的接口，屏蔽掉人工组装依赖链的复杂度)
6. ringBuffer等关键组件解决伪共享问题 + 参考disruptor对特定的数据结构做进一步优化

# 3.MyDisruptor v1版本详细解析
v1版本是整个项目的地基，所以在这里先介绍disruptor的核心设计思想和各关键组件的整体关联以帮助大家更好地理解。
## disruptor核心设计思想
### volatile + 并发写变量的分离
我们知道基于阻塞/唤醒的悲观锁和基于CAS的乐观锁都是并发编程中常见地同步机制，但是其在高并发场景下都有一定的性能损耗。那么有没有开销更低地线程间同步机制呢？
答案是有，既java中volatile修饰符提供地多线程间的内存可见性能力。  
java中volatile修饰的变量具备多线程间的可见性能力，但不提供原子性更新的功能，所以不是线程安全的。这段概述是不全面的，确实在多线程并发读写时，由于缺少原子性更新机制
单靠volatile是无法做到线程安全的，但在**单写者多读者**这一更为特殊的场景下，仅靠volatile提供的内存可见性能力就可以做到并发场景下的线程安全，且其性能开销会更低。
### 一写多读的序列号机制
disruptor从设计一开始就引入了单调递增的序列号机制，每个生产者、消费者线程都有自己独立所属的序列号变量（volatile修饰），其只能由拥有者写入，其它线程只能去读取，做到一写多读。 
* 生产者和消费者通过写自己独占的序列号，读其它线程序列号的方式进行通信
* 生产者每进行一次生产发布，生产者序列号就加1；消费者每进行一次消费，消费者序列号也加1。消费者的序列号永远不能超过生产者
* 当生产者的序列号超过消费者时，说明当前生产速度超过了消费速度；当生产者超过最慢消费者的序列之差和队列容量相等时，需要阻塞生产者，等待消费者消费（逻辑上等于队列已满）
* 反之，当消费者的序列号即将超过生产者时（临界状态恰好等于），则需要阻塞当前消费者，等待生产者生产（逻辑上等于队列为空）  
* 在消费者间存在依赖的场景下，不同于消费者间通过传递队列元素对象来实现依赖关系。当前消费者除了需要关注生产者的序列号，也关注其依赖的上游消费者。使自己的序列号始终不超过上游消费者的序列号，巧妙地实现依赖关系。  
disruptor拆分了传统队列中多写多读的队列头、尾等多读多写的变量，仅凭借内存可见性就完成了生产者和消费者间的通信

## disruptor关键组件关系
todo 各个组件关联图

## 3.1 MySequence序列对象
## 3.2 MyRingBuffer环形队列
## 3.3 MyBatchEventProcessor单线程消费者
## 3.4 MySingleProducerSequencer单线程生产者
## 3.5 MyDisruptor使用Demo分析
## 总结
