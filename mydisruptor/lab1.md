# 1.lmax-Disruptor队列介绍
disruptor是英国著名的金融交易所lmax旗下技术团队开发的一款java实现的高性能内存队列框架。  
发明disruptor的主要目的是为了改进传统的内存队列实现如jdk的ArrayBlockingQueue、LinkedBlockingQueue等在现代CPU硬件上的一些缺陷: 
##### 1. 伪共享问题 
   现代的CPU都是多核的，每个核心都拥有自己独立的高速缓存。高速缓存通常由固定大小的缓存行组成（通常为32字节或64字节）。  
   CPU是以缓存行作为最小单位读写的，而一个缓存行通常会被多个变量占据（32位的引用指针占4字节，64位的引用占8字节）。  
   这样会导致一个问题，即使缓存行上的变量不相关联（比如不属于同一个对象），但只要缓存行上的一个共享变量发生了变化，则整个缓存行都会进行缓存一致性的同步。
   而CPU间缓存一致性的同步是有一定性能损耗的，能避免则尽量避免。这就是所谓的“**伪共享**”问题。  
   而disruptor通过对队列中一些关键变量进行了缓存行的填充，避免其因为不相干的变量读写而无谓的刷新缓存，解决了伪共享的问题。
   关于CPU间缓存一致性相关的内容可以参考下我以前的博客：
   [高速缓存一致性协议MESI与内存屏障](https://www.cnblogs.com/xiaoxiongcanguan/p/13184801.html)
##### 2. 过多的队头、队尾引用等共享变量的争抢
   传统的内存队列由于生产者、消费者都会并发的读写队列头、队列尾的引用和队列size， 
   因此被迫使用了如ReentrantLock等基于OS上下文切换的悲观锁或是CAS机制的乐观锁等互斥机制来保证队列关键数据在多线程并发场景下的安全，
   而即使是CAS这样非阻塞的机制，其为了保障volatile变量在各个CPU核心内的一致性，其性能损耗在追求极限性能的队列中间件上也是不容忽视的
   而disruptor在实现过程中巧妙的引入了全局有序增长的序列号代替了显式的队列头、队列尾，
   大大减少了生产者和消费者间需要并发访问共享变量的场合，从而极大的提高了高并发场景下队列的吞吐量
   
##### 3. 入队、出队时队列元素产生大量垃圾
   juc包下的阻塞队列队列元素在入队时会被创建、出队被消费后就不再被引用从而产生大量的垃圾。 
   disruptor通过基于数组的环形队列，在开始运行前就用空的事件对象填充好整个队列，后续的生产与消费则不允许新增或者删除队列元素，
   而只能配合序列号机制，修改队列元素中的属性来进行生产者和消费者的交互。通过固定队列中的对象，而避免入队、出队时产生不必要的垃圾。  
##### 
   除此之外，disruptor还允许设置消费者间消费的依赖关系（例如A、B消费者消费完毕后，C才能消费），构造高效的事件传输管道。轻松的实现1对1，1对多，多对1等模式的组合  
   更详细的内容可以参考disruptor的官方文档：https://lmax-exchange.github.io/disruptor/disruptor.html
# 2.MyDisruptor介绍
# 3.MyDisruptor v1详细解析
  todo 各个组件关联图
## 3.1 MySequence序列对象
## 3.2 MyRingBuffer环形队列
## 3.3 MyBatchEventProcessor单线程消费者
## 3.4 MySingleProducerSequencer单线程生产者
## 3.5 MyDisruptor使用Demo分析
## 总结
